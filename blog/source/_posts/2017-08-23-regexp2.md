---
title: 正则表达式
date: 2017-09-23 14:22:16
categories:
  - 正则表达式
tag: 
  - 正则表达式
---

## 正文

&ensp;&ensp;&ensp;正则表达式是一个非常强大的工具，掌握了它会极大的提高你的工作效率。
&ensp;&ensp;&ensp;下面就总结一下我常用到的一些模式。
<!--more-->

### 常用匹配

* `.` 用来匹配不包含`换行`的任意字符
* `\s` 匹配空白符（空格、`tab`、换行）
&ensp;&ensp;&ensp;`\S`为`\s`的反义
* `*` 匹配0个或多个字符
* `+` 匹配一个或多个
* `\\` 转义字符
* `[]` 单字符取一个，比如`[a-z]`会匹配所有的小写字母中的一个
  * `[]`中的`^`代表`非`的意思，如`[^a-z]`匹配一个非小写字母的字符
  * 如上所示`-`表示范围，如`[0-9]`匹配从0到9的所有数字中的一个
  * 如果要包含-字符，可以给它加上转义`[\-]`
  * `[]`里面的特殊符有五个：`[]-\^`，其他字符都是普通字符，包括`*.?`等。
* `^` 字符串开始
&ensp;&ensp;&ensp;用`^`可以匹配所有的行（包括空行）
* `$` 字符串的结束
* `{start, end}` 前一个匹配的循环次数。其中start和end都是十进制整数
&ensp;&ensp;&ensp;如`\(ab\)\{3}`匹配`ababab`，其中`()`和需要转义，前后括号都需要转，而`{}`只需要转前括号即可，正则表达式引擎能够自动识别。
* `?`
  * 匹配0个或1个字符
  * 表示使用非贪婪模式
   &ensp;&ensp;&ensp;那么什么是贪婪模式和非贪婪模式呢？贪婪模式就是在符合当前匹配的前提下，匹配尽量多的字符，而非贪婪模式则是匹配尽量少的字符。默认情况下是贪婪模式。
   &ensp;&ensp;&ensp;例如对于字符串`<a>hello</a><a>world</a>`使用模式`<a>.*</a>`进行匹配的话，匹配结果就是`<a>hello</a><a>world</a>`，这就是贪婪模式，虽然到第一个`</a>`的时候就已经能够完成匹配了，但是因为`.*`模式能够匹配任意长度的字符串，而且后面还能找到`</a>`，所有贪婪模式下会继续匹配指导找不到`</a>`。而使用非贪婪模式`<a>.*?</a>`匹配的结果就是`<a>hello</a>`和`<a>world</a>`。
* `|` 或 如模式`ab|bc|de`匹配`ab`或者`bc`或者`de`
* `（)` 分组
&ensp;&ensp;&ensp;有时候啊，需要取出匹配中的一部分数据，这个时候就需要用到分组了。匹配中的`()`用来标示分组，分组从左到右用左括号进行对分组计数（非捕获和环视的左括号不能数），从1开始计数，如模式`(ab)dd(ef)`中`ab`就是分组1，而`ef`就是分组2。
&ensp;&ensp;&ensp;使用分组时，有两种方式：`\group`和`$group`
  * `\group` 模式本身使用子模式使用，如`(ab)\1\1`
  * `$group` 替换时调用模式中分组内容时使用
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如将`adbc`中的`bc`匹配为`de`时，先使用`(ad)bc`模式进行匹配，然后用模式`$1de`进行替换。
* `(?:)` 非捕获组
&ensp;&ensp;&ensp;有的时候`()`只是用来对字符进行分界使用，而不是用来作为子模式，这个时候就会用到非捕获组，如模式`(ab|cd|de)def(zz)`，使用这个模式的时候想要得到后面的一个分组`zz`，而前面的`()`只是用来对字符进行分界。但是这时`zz`的这个分组数为2，如果对前面的`()`进行非捕获`(?:ab|cd|de)def(zz)`，那么`zz`的分组数变为1。

### 高级概念

* 贪婪模式和非贪婪模式
&ensp;&ensp;&ensp;上面已经说明
* 环视
&ensp;&ensp;&ensp;环视也成为零宽断言或断言。其作用是加入一些条件，使得在找到满足的匹配后需要满足这些条件才能满足最后的匹配。主要有下面用法：
  * `(?<=exp)` 匹配前面是exp的
  * `(?<!exp)` 匹配前面不是exp的
  * `(?=exp)` 匹配后面是exp的
  * `(?!exp)` 匹配后面不是exp的
如：
  * `(?<=\d)abc` 匹配前面是数字的，`1abc`匹配，`dabc`不匹配
  * `(?<!\d)abc` 匹配前面不是是数字的，`dabc`匹配，`1abc`不匹配
  * `abc(?=\d)` 匹配后面是数字的，`abc1`匹配，`abcd`不匹配
  * `abc(?!\d)` 匹配后面不是数字的，`abcd`匹配，`abc1`不匹配
&ensp;&ensp;&ensp;有一点要注意，当`(?!exp)`模式放在后面时代表`匹配后面不是exp的`，而它也可以放在匹配模式的前面，这是它代表：`对后面数据的一种过滤`，如模式`(?!\d).*`意思是在所有匹配`.*`的串里，排除`\d`匹配的串。这个作用很实用，常用来过滤数据。
&ensp;&ensp;&ensp;如要匹配`非纯数字和非纯字母的数据`，匹配所有数据的模式是`.*`，匹配纯数字的模式是`^[\d]+$`，匹配纯字母的模式是`^[a-zA-Z]+$`，使用`?!exp`模式排除得到最终模式`(?!^[\d]+$)(?!^[a-zA-Z]+$).*`。这里注意排除数据时，不只能够使用`(?!exp)`，其他的环视表达式放在非正常位置时都可以用来排除数据，如`[A-Z](?<!B)`表示`[A-Z]范围排除B`。
&ensp;&ensp;&ensp;还有就是环视又成为零宽断言，这里的零宽代表什么意思呢，意思就是`(..)`内部匹配到的数据不会放到匹配结果中，如前面的模式`(?=\d)abc`匹配后面是`1`的`abc`，如与`abc1`是匹配的，但是匹配结果是`abc`，不包括`1`。零宽还有另一个意思，对于原字符串，用环视匹配过的部分可以再次利用进行匹配（如果不是环视的话，匹配过的部分是不能再次匹配的），如对于`(?!exp)`排除数据方法的使用，前面例子中，整个匹配过程中，正则表达式一共走了3次字符串匹配，第一次匹配不全部是字母，第二次匹配不全部是数字，第三次匹配全部是字母数字组合，这三次匹配使用的都是一个源字符串。
* 平衡组
&ensp;&ensp;&ensp;当要匹配的内容有嵌套时，就需要使用平衡组了，它的语法我的理解就是模拟了一个栈完成括号匹配：
  * `(?'group')` 将当前组捕获的内容命名为`group`，并压入栈中。
  * `(?'-group')` 从栈中弹出最后压入的名为`group`的内容，如果栈为空，则匹配失败
  * `(?(group)yes|no)` 如果栈中存在名为`group`的内容，则执行`yes`部分，否则执行`no`部分
  * `(?!)` 零宽负向先行断言，总是匹配失败
&ensp;&ensp;&ensp;下面是一个平衡组使用的例子：
```html
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号时，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败
>                         #最外层的右括号
```
* 模式修饰符
  * `i` 忽略大小写
      `((?i)[A-Z]+)c`模式匹配`abcABC`得到的结果是`abc`和`ABC`

## 总结

&ensp;&ensp;&ensp;正则表达式的在书写时可以分为三步:
* 分析要解析的数据
* 用通配符匹配去掉一些不需要的数据
* 使用分组等得到想要的数据

## 学习链接

* [正则表达习题](https://alf.nu/RegexGolf)
* [正则表达式测试](https://regexr.com/)
* [平衡组](http://blog.csdn.net/zm2714/article/details/7946437)

转载请注明:[Artemis的博客](https://BlasphemyAngels.github.io)--> [点此看原文](https://BlasphemyAngels.github.io/2017/09/23/2017-08-23-regexp2/)
